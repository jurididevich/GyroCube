<jittershader name="TFLocomotion">
    <description>Basic Transform Feedback Locomotion</description>
    <param name="position" type="vec3" state="POSITION" />
    <param name="instance_position" type="vec3" state="VERTEX_ATTR0" />
    <param name="instance_velocity" type="vec3" state="VERTEX_ATTR1" />
    <param name="color" type="vec4" state="COLOR" />
    <param name="mvp" type="mat4" state="MODELVIEW_PROJECTION_MATRIX" />
    <language name="glsl" version="1.5">
        <bind param="position" program="vp" />
        <bind param="instance_position" program="vp" />
        <bind param="instance_velocity" program="vp" />
        <bind param="color" program="vp" />
        <bind param="mvp" program="vp" />
        <program name="vp" type="vertex">
<![CDATA[
#version 330 core
// flocking_render
// OpenGL SuperBible
// Example of using transform feedback to implement flocking
// Program by Graham Sellers.

// Flocking render vertex shader

// Model-view-projection matrix
uniform mat4 mvp;

// Instanced attributes (position and velocity of the flock member)
in vec3 instance_position;
in vec3 instance_velocity;
// Geometry input
in vec3 position;
in vec4 color;

// Output color from the vertex shader
flat out vec4 vs_color;

// This is essentially a 'lookat' matrix to make the airplane fly fowards
// and hopefully, stay upright
mat4 calculate_rotation_matrix(vec3 direction)
{
    vec3 forwards = normalize(direction);
    vec3 outwards;
    outwards = cross(forwards, vec3(1.0, 0.0, 0.0)) * forwards.x * forwards.x +
               cross(forwards, vec3(0.0, 1.0, 0.0)) * forwards.y * forwards.y +
               cross(forwards, vec3(0.0, 0.0, 1.0)) * forwards.z * forwards.z;
//     outwards /= (abs(forwards.x) + abs(forwards.y) + abs(forwards.z));
    vec3 up = cross(forwards, outwards);
    outwards = cross(forwards, up);

    vec4 row3 = vec4(forwards, 0.0);
    vec4 row2 = vec4(normalize(outwards), 0.0);
    vec4 row1 = vec4(normalize(up), 0.0);

    return mat4(row1, row2, row3, vec4(0.0));
}

void main(void)
{
    // Get the forwards matrix
    mat4 rotation = calculate_rotation_matrix(instance_velocity);

    // Rotate the airplane geometry into the correct orientation and then
    // offset by position within the flock
    vec4 pos = rotation * vec4(position, 0.0) + vec4(instance_position, 1.0);

    vs_color = color;

    // Output position
    gl_Position = mvp * pos;
}
        ]]>
        </program>
        <program name="gp" type="geometry">
<![CDATA[
#version 330 core
// This is a really simple geometry shader that simply calculates flat shading.
layout (triangles) in;
layout (triangle_strip, max_vertices=3) out;

// Color from the VS
flat in vec4 vs_color[3];

// Output to the FS
flat out vec4 object_color;

void main(void)
{
    int n;
    // Calculate face normal
    vec3 ab = normalize(gl_in[1].gl_Position.xyz - gl_in[0].gl_Position.xyz);
    vec3 ac = normalize(gl_in[2].gl_Position.xyz - gl_in[0].gl_Position.xyz);
    vec3 face_normal = cross(ac, ab);
    // Simple lighting calculation
    vec4 base4 = vs_color[0];
    vec4 color = vec4(vec3(0.2, 0.2, 0.2) + vec3(0.8, 0.8, 0.8) * abs(face_normal).z, 1.0) * base4;

    // Output three vertices
    for (n = 0; n < 3; n++) {
        object_color = color;
        gl_Position = gl_in[n].gl_Position;
        EmitVertex();
    }
    EndPrimitive();
}
]]>
        </program>
        <program name="fp" type="fragment">
<![CDATA[
#version 330 core

flat in vec4 object_color;
layout (location = 0) out vec4 color;

void main(void)
{
    color = object_color;
}
]]>
        </program>
    </language>
</jittershader>        